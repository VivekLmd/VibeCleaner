# VibeCleaner ‚Äî AI-Powered Downloads Folder Organizer

## The Vibe Coding Experiment

**A Real-World Test:** Can we use "Vibe Coding" (describing what we want in plain English to AI) to build a "Vibe Cleaner" (a tool that organizes messy Downloads folders through natural language)?

**My Experience:** Mixed results. This repository represents both the promise and current limitations of agentic AI workflows.

## About

**VibeCleaner** is an experimental AI-powered tool that attempts to understand natural language requests to organize your Downloads folder. It uses Claude or Codex AI to interpret your intent and execute file organization tasks.

**Important Context:** This is my first public repository, born from testing whether AI agents can handle real-world file management. The results revealed significant challenges that are documented here for transparency and collaborative improvement.

### üéØ What VibeCleaner Does

VibeCleaner transforms your chaotic Downloads folder into an organized file system by:

- **Auto-Organization**: Sorts files into categorized folders (Documents, Images, Videos, Archives, etc.)
- **Duplicate Detection**: Identifies and removes duplicate files to save disk space
- **Old File Management**: Archives or deletes files older than specified periods
- **Smart Filtering**: Recognizes file patterns and sorts based on customizable rules
- **Safe Operations**: Dry-run mode shows what will happen before making changes

### ‚ú® Key Features

- **ü§ñ AI-Powered Natural Language Interface**:
  - Talk to VibeCleaner like a human - no commands to memorize
  - Understands requests like "organize my downloads" or "delete old stuff"
  - Works with Claude or Codex AI assistants
  - Interactive chat mode for conversational cleaning
  - Smart fallback to rule-based cleaning if AI unavailable

- **File Type Recognition**: Automatically categorizes files by extension and content
  - Documents (PDF, DOCX, TXT, etc.)
  - Images (JPG, PNG, GIF, etc.)
  - Videos (MP4, AVI, MKV, etc.)
  - Archives (ZIP, RAR, 7Z, etc.)
  - Code files (PY, JS, HTML, etc.)
  - Audio (MP3, WAV, FLAC, etc.)

- **Intelligent Rules Engine**:
  - Move files based on age
  - Sort by file size thresholds
  - Custom naming patterns
  - Subfolder organization by date

- **Safety Features**:
  - Preview mode to see changes before execution
  - Undo functionality for recent operations
  - Whitelist important files
  - Backup before deletion option

- **Scheduling Options**:
  - Run on system startup
  - Periodic cleaning (hourly, daily, weekly)
  - Watch folder for real-time organization
  - Manual trigger via CLI or GUI

### üìã Use Cases

- **Daily Cleanup**: Automatically organize downloads every day
- **Project Files**: Sort project files into dedicated folders
- **Media Management**: Organize photos and videos by date
- **Document Filing**: Keep documents sorted by type and date
- **Disk Space Recovery**: Remove old and duplicate files
- **Download History**: Maintain organized archive of downloads

## ‚ö†Ô∏è Reality Check: Limitations Discovered

Through testing, I discovered significant challenges with current AI agents:

### What Went Wrong

1. **Large Folder Failure**: Both Claude and Codex lose context with too many files
2. **Attention Drift**: AI agents "forget" instructions during complex operations
3. **Inconsistent Results**: Same prompt, different outcomes
4. **Sandbox Limitations**: Codex has severe restrictions that limit real-world usage
5. **Context Window Issues**: Can't handle folders with 1000+ files effectively

### What Worked (Sometimes)

- **Claude**: Excellent at generating code, struggled with file management logic
- **Codex**: Good on small folders despite sandbox limitations
- **Fallback Rules**: Had to implement non-AI backup logic for reliability

### The Solution (Workarounds)

This repository packages the working scripts generated by AI with:
- Task decomposition into smaller passes
- Folder learning systems
- OCR integration for document classification
- Extensive guardrails and safety checks
- Manual fallback for when AI fails

## üìä Empirical Findings from Real Testing

### Test Environment
- **Test Folder**: Real corporate Downloads folder
- **Total Files**: 579 files
- **Categories**: 12 organized subdirectories
- **File Types**: 50+ different extensions
- **Challenges**: Mixed naming conventions, duplicates, versioned files

### What AI Struggled With

1. **Complex File Naming Patterns**
   - Files like "Complete_with_DocuSign_*" (multiple variations)
   - Version numbers: "Report (1).xlsx" through "Report (6).xlsx"
   - Date formats: Multiple inconsistent date patterns
   - Similar names: "2021 Tax Return Vivek.pdf" vs "2021 Tax Return Vivek1.pdf"

2. **Context-Dependent Organization**
   - Same file type belongs in different folders based on content
   - PDFs could be: Tax docs, Contracts, Reports, or Insurance
   - Excel files could be: Financial, Analytics, or Technical
   - AI couldn't determine context without reading file content

3. **Business Logic Complexity**
   - Corporate files require domain knowledge
   - Legal vs Financial vs HR distinctions
   - Temporal relevance (2021 vs 2022 tax files)
   - Relationship between files (invoice + receipt pairs)

4. **Scale Issues**
   - 579 files overwhelmed context window
   - AI lost track after ~100 files
   - Couldn't maintain consistent categorization rules
   - Memory of early decisions degraded

### Success Patterns

- **Small Batches**: Processing 20-30 files at a time worked
- **Clear Extensions**: .jpg, .png consistently categorized
- **Simple Rules**: Date-based archival was reliable
- **Duplicate Detection**: Hash-based matching worked well

## üöÄ Quick Start

### Prerequisites

- **AI Provider**: Install Claude CLI or Codex CLI for AI features
  - Claude: `pip install claude-cli` (or your Claude installation method)
  - Codex: `npm install -g codex-cli` (or your Codex installation method)
  - Set environment variables if needed:
    - `VIBECLEANER_CLAUDE_CMD=claude`
    - `VIBECLEANER_CODEX_CMD=codex`

### Installation

```bash
# Install from PyPI
pip install vibecleaner

# Or install from source
git clone https://github.com/yourusername/vibecleaner.git
cd vibecleaner
pip install .
```

### ü§ñ AI-Powered Usage (Recommended for Non-Technical Users)

```bash
# Initialize VibeCleaner
vibecleaner init

# Ask in natural language
vibecleaner ask "clean up my messy downloads folder"
vibecleaner ask "find and delete duplicate photos"
vibecleaner ask "organize PDFs from last month"
vibecleaner ask "what files are taking up the most space?"

# Interactive chat mode
vibecleaner chat
# Then chat naturally:
# You: my downloads are a mess, help!
# Assistant: I'll help you organize...

# Apply AI suggestions automatically
vibecleaner ask "remove old files" --apply
```

### Manual Usage (Traditional Commands)

```bash
# Preview what will be cleaned (dry run)
vibecleaner clean --dry-run

# Clean downloads folder
vibecleaner clean

# Clean with specific rules
vibecleaner clean --older-than 30 --duplicates

# Watch folder for real-time organization
vibecleaner watch ~/Downloads

# Schedule automatic cleaning
vibecleaner schedule --daily --time 09:00
```

### Configuration

Create a `.vibecleaner.yml` in your home directory:

```yaml
# Download folder path (default: ~/Downloads)
downloads_path: ~/Downloads

# Organization rules
organize:
  Documents:
    extensions: [pdf, doc, docx, txt, odt]
    path: ~/Documents/Downloads
  Images:
    extensions: [jpg, jpeg, png, gif, svg, webp]
    path: ~/Pictures/Downloads
  Videos:
    extensions: [mp4, avi, mkv, mov, wmv]
    path: ~/Videos/Downloads
  Archives:
    extensions: [zip, rar, 7z, tar, gz]
    path: ~/Downloads/Archives

# Cleanup rules
cleanup:
  delete_after_days: 90
  archive_after_days: 30
  min_file_size: 1MB  # Ignore small files
  remove_duplicates: true
  
# Safety settings
safety:
  dry_run_default: true
  backup_before_delete: true
  whitelist_patterns:
    - "important_*"
    - "*.key"
    - "*.license"
```

## üõ†Ô∏è Advanced Features

### Custom Rules

```bash
# Add custom organization rule
vibecleaner rule add --name "Screenshots" \
  --pattern "Screen Shot*" \
  --destination ~/Pictures/Screenshots

# Remove old downloads
vibecleaner clean --older-than 60d --min-size 100MB

# Find and remove duplicates
vibecleaner duplicates --remove --keep-newest
```

### Scheduling (Cross-platform)

```bash
# Linux/Mac: Add to crontab
vibecleaner schedule --cron "0 9 * * *"

# Windows: Add to Task Scheduler  
vibecleaner schedule --windows --daily --time 09:00

# Run as daemon/service
vibecleaner daemon start
```

## üìä Statistics & Reports

```bash
# Show cleaning statistics
vibecleaner stats

# Generate cleaning report
vibecleaner report --last-30-days

# Show disk space saved
vibecleaner savings
```

## üîß Command Reference

| Command | Description |
|---------|-------------|
| `vibecleaner init` | Initialize configuration |
| `vibecleaner clean` | Clean downloads folder |
| `vibecleaner watch` | Watch folder for real-time organization |
| `vibecleaner schedule` | Set up automatic cleaning |
| `vibecleaner undo` | Undo last cleaning operation |
| `vibecleaner stats` | Show cleaning statistics |
| `vibecleaner config` | Edit configuration |

## üõ°Ô∏è Safety & Privacy

- **No Cloud Dependency**: Works entirely offline
- **Local Processing**: Your files never leave your machine
- **Transparent Operations**: Full logs of all actions
- **Reversible Changes**: Undo support for recent operations
- **No Data Collection**: Zero telemetry or analytics

## üìù License

Licensed under the MIT License. See the `LICENSE` file for details.

## ü§ù Call for Contributors: Help Make Vibe Coding Work

This project needs your help! The agentic workflow shows promise but requires significant improvement.

### Areas Needing Help

1. **Context Management**: Better handling of large folders (1000+ files)
2. **Attention Systems**: Prevent AI from losing track during long operations
3. **Prompt Engineering**: More robust prompts that work consistently
4. **Edge Cases**: Handle unusual file types and folder structures
5. **Provider Integration**: Better Claude/Codex integration, add more providers
6. **Learning Systems**: Implement folder pattern recognition
7. **Testing**: Test on diverse, real-world messy folders

### How to Contribute

1. Fork the repository
2. Test on your own messy Downloads folder
3. Document what breaks
4. Submit fixes or improvements
5. Share your experience with agentic workflows

**Special Interest:** If you've successfully implemented attention management or context preservation in agentic systems, your expertise would be invaluable.

See `CONTRIBUTING.md` for technical guidelines.

## üéì Lessons from Building with Vibe Coding

### Key Insights

1. **Agents Need Boundaries**: Unlimited scope leads to failure. Break tasks into small, well-defined chunks.

2. **Context is Everything**: Current AI loses context quickly. Solution: Implement checkpoint systems.

3. **Trust but Verify**: Always preview before execution. AI confidence doesn't equal correctness.

4. **Fallbacks are Essential**: When AI fails (and it will), have deterministic rules ready.

5. **Prompt Management is Complex**: What works once might fail next time. Version and test your prompts.

### The Vibe Coding Reality

**The Promise**: Describe what you want, AI handles implementation.

**The Reality**: You need extensive infrastructure to make it reliable:
- Attention management
- Context preservation  
- Task decomposition
- Error recovery
- Safety guardrails

**The Future**: With community effort, we can build the missing infrastructure to make vibe coding practical.

## üí° Usage Tips

- **Start Small**: Test on folders with <100 files first
- **Always Preview**: Use `--dry-run` before any operation
- **Backup First**: AI can misunderstand dramatically
- **Watch Mode**: Better for real-time organization than bulk cleaning
- **Manual Fallback**: When AI fails, use traditional commands

---

**Important Note**: This tool is experimental. VibeCleaner represents both the potential and current limitations of agentic AI workflows. Use with caution on important files. Always maintain backups.